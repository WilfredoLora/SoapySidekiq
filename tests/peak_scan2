#!/bin/python3

import sys
import csv
import time
import signal
import datetime
import argparse
import serial
import pynmea2

import numpy as np
from matplotlib import pyplot as plt
import SoapySDR
from SoapySDR import *

def read_gps(ser):
    trying = True
    fix = "no"
    lat = "0";
    lat_dir = ""
    lon = "0"
    lon_dir = ""
    timestamp = ""

    while(trying):
        try:
            line = ser.readline()
            newline = str(line, 'utf-8', errors='ignore')
            if "GGA" in newline:
                data = pynmea2.parse(newline)
                timestamp = data.timestamp
                lat, lon, alt = data.latitude, data.longitude, data.altitude
                lat_dir, lon_dir, num_sats = data.lat_dir, data.lon_dir, data.num_sats
                gps_qual = data.gps_qual
                if gps_qual != 0:
                    fix = "yes"
                    trying = False;
                else:
                    fix = "no"
                    trying = False;

        except serial.SerialException as e:
            trying = False;

        except serial.SerialTimeoutException as e:
            trying = False;

    ret_lat = "{:4.6}".format(lat) + " " +lat_dir
    ret_lon = "{:4.6}".format(lon) + " " + lon_dir
    return fix, ret_lat, ret_lon, str(timestamp) 


def handler(signum, frame):
    global running 

    print("ending...")
    running = False
    # Stop streaming
    sdr.deactivateStream(rx_stream)
    sdr.closeStream(rx_stream)
    exit(1)

def main(rx_chan, fs, bw, sfreq, stfreq, port, looptime):

    # Figure out how many times to loop to get one sample across the frequency range
    diff = stfreq - sfreq
    if (diff < bw):
        loops = 1
    else:
        loops = int(diff / bw)
    print(loops)

    ############################################################################################
    # Settings
    ############################################################################################
    if (port != None):
        print(port) 
        ser = serial.Serial(port, BAUD, timeout=2.0)

    running = True

    # Data transfer settings
    N = 65536               # Number of complex samples per transfer
    use_agc = False          # Use or don't use the AGC
    timeout_us = int(10e6)
    rx_bits = 12
    
    if (port == None):
        header = "Time(UTC), Peak Frequency, Peak Power (dBm)\n"
    else:
        header = "Time(UTC), GPS Sat Lock, Latitude, Longitude, Peak Frequency, Peak Power (dBm)\n"


    signal.signal(signal.SIGINT, handler)

#    args = dict(card = '1')
    args = dict(serial = '8N55')
    sdr = SoapySDR.Device(args)
    SoapySDR.setLogLevel(SOAPY_SDR_ERROR)

    # Create data buffer and start streaming samples to it
    rx_buff = np.empty((loops,2 * N), np.int16)                 # Create memory buffer for data stream
    maxElement = np.empty(loops)
    peak_freq = np.empty(loops)

    f = open('output.csv', 'w', encoding='UTF8') 
    out = "Sample Rate, " + "{:10.0f}".format(fs) + "\n"
    f.write(out)
    out = "Bandwidth, "+ "{:10.0f}".format(bw) + "\n"

    f.write(out)
    out = "Start Freq, " + "{:10.0f}".format(sfreq) + "\n"
    f.write(out)
    out = "Stop Freq, " + "{:10.0f}".format(stfreq) + "\n\n"

    f.write(out)
    f.write(header)

    ############################################################################################
    # Receive Signal
    ############################################################################################

    sdr.setSampleRate(SOAPY_SDR_RX, rx_chan, fs)            # Set sample rate
    sdr.setBandwidth(SOAPY_SDR_RX, rx_chan, bw)             # Set sample rate
    sdr.setGain(SOAPY_SDR_RX, rx_chan, 0)                   # Set the gain mode

    rx_stream = sdr.setupStream(SOAPY_SDR_RX, SOAPY_SDR_CS16, [rx_chan])  # Setup data stream

    while running:
        max_index = 0
        max_power = -150

        curFreq = (sfreq + (bw/2))

        # Read the samples from the data buffer
        for i in range(loops):

#            print("reading stream", i, curFreq)
            sdr.setFrequency(SOAPY_SDR_RX, rx_chan, curFreq)           # Tune the LO

            sdr.activateStream(rx_stream)  # this turns the radio on
            sr = sdr.readStream(rx_stream, [rx_buff[i]], N, timeoutUs=timeout_us)
            sdr.deactivateStream(rx_stream)  # this turns the radio off

            rc = sr.ret # number of samples read or the error code
            assert rc == N, 'Error Reading Samples from Device (error code = %d)!' % rc

            # Convert interleaved shorts (received signal) to numpy.complex64 normalized between [-1, 1]
            s0 = rx_buff[i].astype(float) / np.power(2.0, rx_bits-1)
            s = (s0[::2] + 1j*s0[1::2])


            # Take the Fourier transform of the signal and perform FFT Shift
            S = np.fft.fftshift(np.fft.fft(s, N) / N)
            S1 = 20*np.log10(np.abs(S))

            # Get the maximum element from a Numpy array
            maxElement[i] = np.amax(S1)

            result = np.where(S1 == np.amax(S1))

            f_mhz = (curFreq + (np.arange(0, fs, fs/N) - (fs/2) + (fs/N))) / 1e6
            peak_freq[i] = f_mhz[result[0]]

            if maxElement[i] > max_power:
                max_index = i
                max_power = maxElement[i]
#                print(peak_freq[i], maxElement[i])

#            print(peak_freq[i], maxElement[i])
            curFreq += bw

        
        now =    datetime.datetime.now().strftime("%d-%b-%Y (%H:%M:%S)")
        print(now)
 
        if (port != None):
            fix, lat, lon, timestamp = read_gps(ser);
            print("gps lock:", fix, "latitude:", lat, "longitude:", lon)

        print('Max Power (dBm): ', "{:.0f}".format(maxElement[max_index]))
        print('at Freq (MHz):', "{:10.3f}".format(peak_freq[max_index]))
      
       
        if (port == None):
            row = now + ', ' + "{:10.0f}".format((peak_freq[max_index] * 1000000)) + ', ' + "{:.0f}".format(maxElement[max_index]) + ' \n'
        else:
            row = now + ', ' + fix + ', '  + lat + ', '  + lon + ', '  + "{:10.0f}".format((peak_freq[max_index] * 1000000)) + ', ' + "{:.0f}".format(maxElement[max_index]) + ' \n'
        print("")
        f.write(row)
        time.sleep(looptime)


def parse_command_line_arguments():
    """ Create command line options """
    help_formatter = argparse.ArgumentDefaultsHelpFormatter
    parser = argparse.ArgumentParser(description='scan for peaks, build a csv file ',
                                     formatter_class=help_formatter)
    parser.add_argument('-chan', type=int, required=False, dest='chan',
                        default=0, help=' Channel')
    parser.add_argument('-s', type=float, required=False, dest='fs',
                        default=20e6, help='Sample Rate')
    parser.add_argument('-bw', type=float, required=False, dest='bw',
                        default=20e6, help='Bandwidth')
    parser.add_argument('-sf', type=float, required=False, dest='sfreq',
                        default=100e6, help='Starting Frequency')
    parser.add_argument('-stf', type=float, required=False, dest='stfreq',
                        default=600e7, help='Stopping Frequency')
    parser.add_argument('-p', required=False, dest='port',
                        default=None, help='GPS Port')
    parser.add_argument('-t', type=int, required=False, dest='looptime',
                        default=3, help='Time between tests')
    return parser.parse_args(sys.argv[1:])


if __name__ == '__main__':

    PORT = "/dev/ttymxc0"
    BAUD = 9600

    pars = parse_command_line_arguments()
    print(pars.chan, pars.fs, pars.bw, pars.sfreq, pars.stfreq, pars.port, pars.looptime)
    main(pars.chan, pars.fs, pars.bw, pars.sfreq, pars.stfreq, pars.port, pars.looptime)
    f.close()
